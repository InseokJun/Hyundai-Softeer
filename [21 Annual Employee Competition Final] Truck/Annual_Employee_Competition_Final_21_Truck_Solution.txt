[문제 접근법 및 풀이 방법]

--- 고려 사항 1 ---

문제에서 설정한 N이 100000이기에 N 제곱의 접근법으로 해결하면 안된다.  -> NlogN의 접근이 필요하다. 

--- 고려 사항 2 ---

입력의 형식과 출력의 형식에 주의하여 Input Data 형태를 올바르게 받고 올바르게 Output을 출력하도록 한다. 





[변수 의미]

변수의 의미는 최대한 변수 이름에 반영하도록 노력하였다. 

- consumer_num => 몇 명의 소비자가 있는지를 의미하며 단순한 정수 형태이다.

- consumer_proposal => 소비자들의 제안을 의미하며 이는 [신차의 크기, 지불 의향 가격, 소비자 ID] 형태로 저장하였다. 

- temp => Input Data를 원하고자 하는 형태로 만들기 위해 단순히 System에서 주는 Input을 잠시 저장하는 변수이다. 

- scenario_num => 설정한 시나리오의 개수를 의미하며 단순한 정수 형태이다.

- scenario => 설정한 시나리오를 의미하며 이는 [목표 매출, 시나리오 ID] 형태로 저장하였다. 

- amount_per_consumer => 소비자 각각의 지불 비용을 의미하며 이는 Index 0을 제외하고 소비자 ID에 맞게 Index를 다룰 수 있도록 하였다. 

- revenue => 판매 시 얻을 수 있는 수익을 의미하며 단순한 정수 형태이다. 

- sidx => 시나리오 List 접근을 위한 index를 의미하며 단순한 정수 형태이다. 





[풀이 방법 설명]

1. 문제에서 주어진 입력 형태에 맞도록 Input Data를 받아온다. 

2. 받아온 Input Data 중 필요한 부분들을 가지고 Data를 재구성한다. 
   - 기존 Input Data 첫 인자는 Proposal의 개수로 이는 단순 반복문에 사용하고 해당 인자를 반영하지 않았다. 
   - 문제 풀이와 정렬한 후 다시 원상 복구를 위해 ID 정보를 추가하여 나타냈다.

3. 소비자 제안 정보를 지니는 List를 신차 크기에 대해 오름차순 정렬한다. 

4. 시나리오를 목표 매출에 대해 오름차순 정렬한다.

5. 존재하는 모든 소비자 제안에 대한 반복을 진행한다. 

6. 반복을 진행하며 얻는 수익이 목표 매출 이상이 되는 경우를 판별한다. 

7. 모든 제안에 대해 반복을 마무리 한 후 만족하지 못하는 시나리오에 대해 -1을 추가한다. 

8. 다시 기존의 출력 순서대로 나타내기 위해 ID를 기준으로 재정렬한다. 

9. 원하는 Output 형태로 출력한다. 





[알아두면 좋은 문법] 

- 1차원 이상의 List를 Sort 하는 경우 가장 첫 인자를 가지고 Sort 하게 된다. 

- map Function을 사용한 후 이를 그대로 출력하면 map Object가 출력된다.

- Sort하는 과정에서 기준을 변경하고자 하는 경우 key Parameter를 사용하며 Lambda 함수로 표현한다. 





[얻은 교훈]

- List에 대한 원소들 접근에 있어 값이 많은 경우 혼돈을 방지하여 각 원소에 대한 변수를 지정한 후 사용하는 것이 효과적이고 가독성에 좋다.

- Sort에 있어 순서를 기억해두어야 하는 경우 새로운 값을 추가한 후 이를 사용하는 방법이 존재한다. 

- for 반복문과 while 반복문 각각에 대한 사용이 익숙해야한다.
