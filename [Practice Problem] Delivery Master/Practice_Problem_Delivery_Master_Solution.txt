[문제 접근법 및 풀이 방법]



--- 고려 사항 1 ---

Rail 순서를 고려하기에 순열을 나타내는 방법에 대해 알고 있어야 한다. 

--- 고려 사항 2 ---

문제 상황에 따른 반복문 사용과 반복문 내 반복문 사용들에 익숙해야 한다. 

--- 고려 사항 3 ---

모든 경우에 대한 최소나 최대에 해당하는 값을 비교할 수 있는 Algorithm에 대해 알고 있어야 한다.



[변수 의미]

변수의 의미는 최대한 변수 이름에 반영하도록 노력하였다. 

- rail_num => Rail의 수를 의미하며 이는 단순한 정수 형태로 주어진다. 
- basket_weight => 문제에서 주어진 basket에 담을 수 있는 최대 무게 제한을 의미하며 이는 단순한 정수 형태로 주어진다. 
- work_num => basket 제한 무게를 넘겨 basket을 나르게 되는 경우로 이는 일을 한 횟수를 의미하며 이는 단순한 정수 형태로 주어진다. 

- rail_weight_list => rail_num에 대한 Rail 각각의 basket 무게를 저장하며 이는 List의 형태로 주어진다. 
- min_total_weight => 구하고자 하는 최종 결과로 이는 최소의 무게로 일할 때에 해당하는 무게를 의미하며 이는 단순한 정수 형태로 주어진다. 

- rail => Permutation의 모든 경우 중 하나의 경우들을 의미하며 이는 현재 Rail에 대한 정보를 지니며 Code 내에서 이를 List로 변형하여 사용한다. 

- rail_idx => rail이라는 List 변수에 접근하기 위한 index를 의미하며 이는 단순한 정수 형태로 주어진다.
- work_count => 현재까지 basket을 나른 수를 의미하며 이는 일한 횟수를 나타내고 이는 단순한 정수 형태로 주어진다. 
- total_weight => 하나의 for 반복문 동안 나른 전체 weight를 의미하여 이는 일을 하며 나른 basket의 전체 무게를 의미하며 단순한 정수 형태로 나타난다. 
- basket_now_weight => 하나의 while문과 if문을 통해 나타나는 현재 들고 있는 basket의 weight를 의미하며 이는 나르기 직전까지의 bakset 무게를 의미하며 정수로 나타난다. 



[풀이 방법 설명]

1. 문제에서 주어진 입력 형태에 맞도록 Input Data를 받아온다. 

2. 최종적인 출력이 최솟값을 나타내기에 최종 출력을 나타내는 변수를 선언하고 이를 최대한 커다란 값을 사용하여 초기화한다.  

3. itertools Module의 Permutations Function을 사용하여 문제에서 주어진 상황에 대한 경우의 수를 구하고 이를 for 반복문을 이용하여 각 경우에 대하여 반복을 진행한다. 

4. for 문 내부에서 필요한 변수들을 선언한다.

5. 현재 들고 있는 basket의 무게와 다음 rail을 통해 담아야하는 box 무게 합이 basket 제한 무게 초과 여부를 if문을 이용하여 판별한다.

6. 제한 무게를 초과하지 않는 경우 현재 들고 있는 basket에 다음 rail의 box 무게를 누적하며 이는 제한 무게를 초과하지 않기에 다음 상자를 추가적으로 basket에 담는 것을 의미한다. 

7. 방금 접근한 rail에 대한 정보를 없애는 것이 아니라 이를 다시 뒤로 보내 후에 발생하는 추가적인 경우의 수를 고려할 수 있도록 한다. 

8. 다음 Rail에 대한 접근을 위해 rail_idx를 증가시킨다. 

9. 만약 제한 무게를 초과하는 경우 현재 들고 있는 basket에 더 이상 추가적인 box를 담을 수 없는 것을 의미한다.

10. 현재까지의 무게를 total_weight에 누적한 후 지금까지 들고 있던 무게의 basket을 옮겨 일한 횟수 work_count를 증가시킨다. 

11. 현재까지 들고 있던 basket을 옮기고 새로운 basket에 물건을 채우는 작업을 진행해야 하기에 basket_now_weight를 0으로 초기화한다. 

12. 해당하는 경우를 주어진 work_num이 될 때 까지 반복한다. 

13. 반복이 종료되는 시점에서 해당 반복문을 진행하면서 구한 total weight가 전체적인 경우에 대한 최소 무게인지 비교한다. 

14. 모든 경우에 대한 최소 무게인 min_total_weight를 출력한다. 



[알아두면 좋은 문법] 

- itertools Module에 대해 알고 있으면 좋다. 

- Permutation과 Combination에 대한 문제들이 많이 존재하기에 이들에 대한 사용과 원리 및 접근 방법에 대해 알고 있으면 좋다. 

- For 반복문과 While 반복문의 차이와 사용하면 좋은 경우에 대해 알고 다양한 상황에 맞는 반복문 활용에 대해 알고 있으면 좋다. 

- 문제 해결을 위한 여러 변수를 선언하고 이들에 대한 형태와 이름들을 가독성이 좋게 나타내어 길고 복잡한 문제에 대한 코드 이해를 높이는 방법 역시 중요하다.

- 최솟값을 구하는 문제에서 해당하는 변수의 값을 최댓값으로 초기화하는 작업을 수행하는데 이 경우에 임의의 큰 수를 이용하기 보단 sys Module의 Maxsize를 사용하면 좋다.



[얻은 교훈]

- 길고 복잡한 문제에 대해 실제 환경이라고 생각하고 이들에 대해 상상하며 문제에 접근하면 보다 문제 이해 및 코드 구현에 용이하다. 

- 각 변수를 초기화하고 update하는 위치는 매우 중요하며 이것이 구현한 Algorithm 결과에 영향을 미칠 수 있다. 

